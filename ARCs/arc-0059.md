---
arc: 59
title: ASA Vault Router
description: An application that can route ASAs to users or hold them to later be claimed
author: Joe Polny (@joe-p), Brian Whippo (@silentrhetoric)
discussions-to: <URL>
status: Draft
type: Meta
category: ARC
created: 2024-03-08
requires (*optional): 4, 54
---

## Abstract
The goal of this standard is to establish a standard in the Algorand ecosystem by which ASAs can be sent to an intended receiver even if their account is not opted in to the ASA.  

A wallet custodied by an application will be used to custody assets on behalf of a given user, with only that user being able to withdraw assets. A master application will be used to map vault addresses to user address. This master application can route ASAs to users performing whatever actions are necessary. 

If integrated into ecosystem technologies including wallets, explorers, and dApps, this standard can provide enhanced capabilities around ASAs which are otherwise strictly bound at the protocol level to require opting in to be received.

## Motivation
Algorand requires accounts to opt in to receive any ASA, a fact which simultaneously:

1. Grants account holders fine-grained control over their holdings by allowing them to select which assets to allow and preventing receipt of unwanted tokens.
2. Frustrates users and developers when accounting for this requirement especially since other blockchains do not have this requirement.

This ARC lays out a new way to navigate the ASA opt in requirement. 

### Contemplated Use Cases

The following use cases help explain how this capability can enhance the possibilities within the Algorand ecosystem.

#### Airdrops

An ASA creator who wants to send their asset to a set of accounts faces the challenge of needing their intended receivers to opt in to the ASA ahead of time, which requires non-trivial communication efforts and precludes the possibility of completing the airdrop as a surprise.  This claimable ASA standard creates the ability to send an airdrop out to individual addresses so that the receivers can opt in and claim the asset at their convenience--or not, if they so choose.  

#### Reducing New User On-boarding Friction

An application operator who wants to on-board users to their game or business may want to reduce the friction of getting people started by decoupling their application on-boarding process from the process of funding a non-custodial Algorand wallet, if users are wholly new to the Algorand ecosystem.  As long as the receiver's address is known, an ASA can be sent to them ahead of them having ALGOs in their wallet to cover the minimum balance requirement and opt in to the asset.


## Specification
The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC-2119</a>.

### Interface

```json
"methods": [
    {
      "name": "arc59_optRouterIn",
      "desc": "Opt the ARC59 router into the ASA. This is required before this app can be used to send the ASA to anyone.",
      "args": [
        {
          "name": "asa",
          "type": "uint64",
          "desc": "The ASA to opt into"
        }
      ],
      "returns": {
        "type": "void"
      }
    },
    {
      "name": "arc59_getAssetSendInfo",
      "args": [
        {
          "name": "receiver",
          "type": "address",
          "desc": "The address to send the asset to"
        },
        {
          "name": "asset",
          "type": "uint64",
          "desc": "The asset to send"
        }
      ],
      "returns": {
        "type": "(uint64,uint64)",
        "desc": "The number of itxns sent and the MBR required to send the asset to the receiver"
      }
    },
    {
      "name": "arc59_sendAsset",
      "desc": "Send an asset to the receiver",
      "args": [
        {
          "name": "axfer",
          "type": "axfer",
          "desc": "The asset transfer to this app"
        },
        {
          "name": "receiver",
          "type": "address",
          "desc": "The address to send the asset to"
        }
      ],
      "returns": {
        "type": "address",
        "desc": "The address that the asset was sent to (either the receiver or their vault)"
      }
    },
    {
      "name": "arc59_claim",
      "desc": "Claim an ASA from the vault",
      "args": [
        {
          "name": "asa",
          "type": "uint64",
          "desc": "The ASA to claim"
        }
      ],
      "returns": {
        "type": "void"
      }
    },
    {
      "name": "arc59_burn",
      "desc": "Burn the ASA from the vault with ARC54",
      "args": [
        {
          "name": "asa",
          "type": "uint64",
          "desc": "The ASA to burn"
        },
        {
          "name": "arc54App",
          "type": "uint64",
          "desc": "The ARC54 app to burn the ASA to"
        }
      ],
      "returns": {
        "type": "void"
      }
    },
  ]
```

## Rationale
This design was created to offer a standard mechanism by which wallets, explorers, and dapps could enable users to send, receive, and find claimable ASAs without requiring any changes to the core protocol.  

This ARC is intended to replace [ARC12](./arc-0012.md). This ARC is simpler than [ARC12](./arc-0012.md), with the main feature lost being senders not getting back MBR. Given the significant reduction in complexity it is considered to be worth the tradeoff. No way to get back MBR is also another way to disincentivize spam.

## Backwards Compatibility
All ARCs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The ARC must explain how the author proposes to deal with these incompatibilities. ARC submissions without a sufficient backwards compatibility treatise may be rejected outright.

## Test Cases

TODO

## Reference Implementation

### TEALScript

```ts
/* eslint-disable max-classes-per-file */

// eslint-disable-next-line import/no-unresolved, import/extensions
import { Contract } from '@algorandfoundation/tealscript';

class ControlledAddress extends Contract {
  @allow.create('DeleteApplication')
  new(): Address {
    sendPayment({
      rekeyTo: this.txn.sender,
    });

    return this.app.address;
  }
}

export class ARC59 extends Contract {
  vaults = BoxMap<Address, Address>();

  /**
   * Opt the ARC59 router into the ASA. This is required before this app can be used to send the ASA to anyone.
   *
   * @param asa The ASA to opt into
   */
  arc59_optRouterIn(asa: AssetID): void {
    sendAssetTransfer({
      assetReceiver: this.app.address,
      assetAmount: 0,
      xferAsset: asa,
    });
  }

  /**
   * Gets an existing or create a vault for the given address
   */
  private getOrCreateVault(addr: Address): Address {
    if (this.vaults(addr).exists) return this.vaults(addr).value;

    const vault = sendMethodCall<typeof ControlledAddress.prototype.new>({
      onCompletion: OnCompletion.DeleteApplication,
      approvalProgram: ControlledAddress.approvalProgram(),
      clearStateProgram: ControlledAddress.clearProgram(),
    });

    this.vaults(addr).value = vault;

    return vault;
  }

  /**
   *
   * @param receiver The address to send the asset to
   * @param asset The asset to send
   *
   * @returns The number of itxns sent and the MBR required to send the asset to the receiver
   */
  arc59_getAssetSendInfo(receiver: Address, asset: AssetID): { itxns: uint64; mbr: uint64 } {
    const info: { itxns: uint64; mbr: uint64 } = { itxns: 1, mbr: 0 };

    if (receiver.isOptedInToAsset(asset)) return info;

    if (!this.vaults(receiver).exists) {
      // Two itxns to create vault (create + rekey)
      // One itxns to send MBR
      // One itxn to opt in
      info.itxns += 4;

      // Calculate the MBR for the vault box
      const preMBR = globals.currentApplicationAddress.minBalance;
      this.vaults(receiver).value = globals.zeroAddress;
      const boxMbrDelta = globals.currentApplicationAddress.minBalance - preMBR;
      this.vaults(receiver).delete();

      // MBR = MBR for the box + min balance for the vault + ASA MBR
      info.mbr = boxMbrDelta + globals.minBalance + globals.assetOptInMinBalance;

      return info;
    }

    const vault = this.vaults(receiver).value;

    if (!vault.isOptedInToAsset(asset)) {
      // One itxn to opt in
      info.itxns += 1;

      if (!(vault.balance >= vault.minBalance + globals.assetOptInMinBalance)) {
        // One itxn to send MBR
        info.itxns += 1;

        // MBR = ASA MBR
        info.mbr = globals.assetOptInMinBalance;
      }
    }

    return info;
  }

  /**
   * Send an asset to the receiver
   *
   * @param receiver The address to send the asset to
   * @param axfer The asset transfer to this app
   *
   * @returns The address that the asset was sent to (either the receiver or their vault)
   */
  arc59_sendAsset(axfer: AssetTransferTxn, receiver: Address): Address {
    verifyAssetTransferTxn(axfer, {
      assetReceiver: this.app.address,
    });

    // If the receiver is opted in, send directly to their account
    if (receiver.isOptedInToAsset(axfer.xferAsset)) {
      sendAssetTransfer({
        assetReceiver: receiver,
        assetAmount: axfer.assetAmount,
        xferAsset: axfer.xferAsset,
      });

      return receiver;
    }

    const vaultExisted = this.vaults(receiver).exists;
    const vault = this.getOrCreateVault(receiver);

    if (!vault.isOptedInToAsset(axfer.xferAsset)) {
      let vaultMbrDelta = globals.assetOptInMinBalance;
      if (!vaultExisted) vaultMbrDelta += globals.minBalance;

      // Ensure the vault has enough balance to opt in
      if (vault.balance < vault.minBalance + vaultMbrDelta) {
        sendPayment({
          receiver: vault,
          amount: vaultMbrDelta,
        });
      }

      // Opt the vault in
      sendAssetTransfer({
        sender: vault,
        assetReceiver: vault,
        assetAmount: 0,
        xferAsset: axfer.xferAsset,
      });
    }

    // Transfer the asset to the vault
    sendAssetTransfer({
      assetReceiver: vault,
      assetAmount: axfer.assetAmount,
      xferAsset: axfer.xferAsset,
    });

    return vault;
  }

  /**
   * Claim an ASA from the vault
   *
   * @param asa The ASA to claim
   */
  arc59_claim(asa: AssetID): void {
    const vault = this.vaults(this.txn.sender).value;

    const preMBR = vault.minBalance;

    sendAssetTransfer({
      sender: vault,
      assetReceiver: this.txn.sender,
      assetAmount: vault.assetBalance(asa),
      xferAsset: asa,
      assetCloseTo: this.txn.sender,
    });

    sendPayment({
      sender: vault,
      receiver: this.txn.sender,
      amount: preMBR - vault.minBalance,
    });
  }

  /**
   * Burn the ASA from the vault with ARC54
   *
   * @param asa The ASA to burn
   * @param arc54App The ARC54 app to burn the ASA to
   */
  arc59_burn(asa: AssetID, arc54App: AppID) {
    const vault = this.vaults(this.txn.sender).value;

    // opt the arc54 app into the ASA if not already opted in
    if (!arc54App.address.isOptedInToAsset(asa)) {
      sendPayment({
        receiver: arc54App.address,
        amount: globals.assetOptInMinBalance,
      });

      sendMethodCall<[AssetReference], void>({
        sender: vault,
        name: 'arc54_optIntoASA',
        methodArgs: [asa],
        applicationID: arc54App,
      });
    }

    const preMBR = vault.minBalance;

    sendAssetTransfer({
      sender: vault,
      assetReceiver: arc54App.address,
      assetAmount: vault.assetBalance(asa),
      xferAsset: asa,
      assetCloseTo: arc54App.address,
    });

    sendPayment({
      sender: vault,
      receiver: this.txn.sender,
      amount: preMBR - vault.minBalance,
    });
  }
}
```

## Security Considerations

The ARC59 application controls all user vaults. If this contract is compromised, user assets might also be compromised.

## Copyright
Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CCO</a>.
