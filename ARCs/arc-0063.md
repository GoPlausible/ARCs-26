---
arc: 63
title: Lsig Plug-In Signer for Msig Vault
description: Delegated multisig-account controlled by one account
author: Stéphane BARROSO (@SudoWeezy)
discussions-to: https://github.com/algorandfoundation/ARCs/issues/303
status: Draft
type: Standards Track
category: ARC
created: 2024-07-16
---

## Abstract

This ARC proposes a method for creating a delegated multisig account controlled by one account and a Logic Signature (Lsig).

## Motivation

The motivation behind this ARC is to extend Algorand account features by enabling third-party "Plug-Ins" using a combination of delegated Lsig and Multi-Signature accounts, which act as vaults. This approach allows anyone to sign the Lsig for the vault, while maintaining security and control through a classic algorand account.

## Specification

The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in <a href = "https://www.ietf.org/rfc/rfc2119.txt">RFC-2119</a>

### Components

1. **Owner Account**: Vault's Owner
1. **Lsig Plug-In**: Provided by a third party.
1. **Plug-In Signer**: Created by generating a new key pair
1. **1/2 Msig Account**: Comprises the owner's address, the Lsig address, and the plug-in signer.

### Steps

We will use the following Lsig plug-in for our illustrative purposes:
**DO NOT USE IN PRODUCTION**

```python
teal_program = """
#pragma version 10
txn TypeEnum
pushint 4
==
txn AssetAmount
pushint 0
==
&&
txn RekeyTo
global ZeroAddress
==
&&
txn Fee
global MinTxnFee
==
&&
return
"""
compiled_program = client.compile(teal_program)
program = base64.b64decode(compiled_program["result"])
lsig = transaction.LogicSigAccount(program)


```

1. **Generate Plug-In Signer**:
    - Generate a random new account that we will only use once.

    ```python
    plug_in_sk, plug_in_addr  = account.generate_account()
    ```

2. **Sign Lsig with Plug-In Signer**:
    - Sign the Lsig using the plug-in signer.
    - Publish the public signature on the indexer.

    ```python
        public_key, secret_key = nacl.bindings.crypto_sign_seed_keypair(base64.b64decode(plug_in_sk)[: constants.key_len_bytes])
        message = constants.logic_prefix + program
        raw_signed = nacl.bindings.crypto_sign(message, secret_key)
        crypto_sign_BYTES = nacl.bindings.crypto_sign_BYTES
        signature = nacl.encoding.RawEncoder.encode(raw_signed[:crypto_sign_BYTES])
        plug_in_public_sig = base64.b64encode(signature).decode()
    ```

3. **Create 1/2 Msig Account**:
    - Create a multi-signature account with owner address, the Lsig address, and the plug-in signer.

    ```python
    owner_vault_msig = transaction.Multisig(1,1,[owner_addr, plug_in_addr])
    ```

    - Add a transaction note to the transaction to help third party to retrieve signer and vault information.

    ```json
        {
            "pk": plug_in_addr,
            "sk": plug_in_public_sig,
            "lsig": lsig.address(),
        }
    ```

    - Prefix the note following the [ARC-2](./arc-0002.md) standard. `arc63:j`

    ```python
    ptxn = transaction.PaymentTxn(
        owner_addr, sp, owner_vault_msig.address(), int(1e6), note=f"arc_63:j{note_field}"
    ).sign(owner_sk)
    ```

4. **Opt-In to Msig Vault**:
    - Anyone can opt-in to the Msig vault using the plug-in signer’s public address and the published signature.

    ```python
    optin_txn = AssetTransferTxn(
        sender=owner_vault_msig.address(),
        sp=sp,
        receiver=owner_vault_msig.address(),
        amt=0,
        index=a_id,
    )
    lsig.lsig.msig = owner_vault_msig
    lsig.append_to_multisig(plug_in_sk) # signature from plug_in_public
    lstx = LogicSigTransaction(optin_txn, lsig)
    ```

5. **Rekey Plug-In Signer**:
    - Rekey the plug-in signer to the zero address to prevent any further usage.

> As you cant't rekey to the zero address directly, you can create a multisig signature with only  zero address in it.

```python
    zero_msig = transaction.Multisig(1,1,[constants.ZERO_ADDRESS])
    rekey_txn = transaction.PaymentTxn(
        plug_in_addr, sp, plug_in_addr, 0, rekey_to=zero_msig.address()
    )
```

> The rekeying process is a **RECOMMENDED** extra-step of security, but **MAY** be avoided if the plug_in private key is not stored at any moment in time.

### Rekeying Process

The plug-in signer is rekeyed to the zero address to eliminate the risk of unauthorized transactions. This ensures that the signer cannot be used post-creation, maintaining the integrity of the multi-signature setup.

### Schema

![ARC Status Diagram](../assets/arc-0063/image.png)

## Rationale

The rationale for this design is to leverage third-party Lsig plug-ins. By rekeying the plug-in signer, we mitigate risks associated with its misuse, while the multi-signature account setup ensures controlled access and flexibility in asset management.

## Backwards Compatibility

This ARC introduces no backward incompatibilities. It builds upon existing Algorand functionalities, ensuring seamless integration with current systems.

## Reference Implementation

An example implementation in Python is provided, demonstrating the creation of a plug-in signer, signing an Lsig, and opting into a multi-signature vault.

[Create_Opt_in_Plug_in](../assets/arc-0063/create_plugin.py)

## Security Considerations

The key security consideration is the rekeying of the plug-in signer to the zero address. This step is crucial to prevent any unauthorized use of the signer post-creation. Additionally, the inherent security of multi-signature accounts provides an added layer of protection.

## Copyright

Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CCO</a>.
