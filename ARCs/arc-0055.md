---
arc: 55
title: On-Chain storage/transfer for Algorand Multisig
description: A smart contract that stores transactions and signatures for simplified multisignature use on Algorand.
author: Steve Ferrigno (@nullun)
discussions-to: https://github.com/algorandfoundation/ARCs/issues/254
status: Draft
type: Standards Track
category: Interface
created: 2023-10-16
requires: 4, 28
---

## Abstract

This ARC proposes the utilization of on-chain smart contracts to facilitate the storage and transfer of Algorand multisignature metadata, transactions, and corresponding signatures for the respective multisignature sub-accounts.

## Motivation

Multisignature (multisig) accounts play a crucial role in enhancing security and control within the Algorand ecosystem. However, the management of multisig accounts often involves intricate off-chain coordination and the distribution of transactions among authorized signers. There exists a pressing need for a more streamlined and simplified approach to multisig utilization, along with an efficient transaction signing workflow.

## Specification

The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC-2119</a>.

### ABI

A compliant smart contract, conforming to this ARC, **MUST** implement the following interface:

```json
{
  "name": "ARC-55",
  "desc": "On-Chain Msig App",
  "methods": [
    {
      "name": "arc55_setup",
      "args": [
        {
          "name": "threshold",
          "type": "uint8",
          "desc": "Initial multisig threshold, must be greater than 0"
        },
        {
          "name": "addresses",
          "type": "address[]",
          "desc": "Array of addresses that make up the multisig"
        }
      ],
      "desc": "Setup On-Chain Msig App. This can only be called whilst no transaction groups have been created.",
      "returns": {
        "type": "void",
        "desc": ""
      }
    },
    {
      "name": "arc55_newTransactionGroup",
      "args": [],
      "desc": "",
      "returns": {
        "type": "uint64",
        "desc": ""
      }
    },
    {
      "name": "arc55_addTransaction",
      "args": [
        {
          "name": "costs",
          "type": "pay",
          "desc": ""
        },
        {
          "name": "transactionGroup",
          "type": "uint64",
          "desc": "Transaction Group nonce"
        },
        {
          "name": "index",
          "type": "uint8",
          "desc": "Transaction position within atomic group to add"
        },
        {
          "name": "transaction",
          "type": "byte[]",
          "desc": "Transaction to add"
        }
      ],
      "desc": "Add a transaction to an existing group. Only one transaction should be included per call",
      "returns": {
        "type": "void",
        "desc": ""
      }
    },
    {
      "name": "arc55_removeTransaction",
      "args": [
        {
          "name": "transactionGroup",
          "type": "uint64",
          "desc": "Transaction Group nonce"
        },
        {
          "name": "index",
          "type": "uint8",
          "desc": "Transaction position within atomic group to remove"
        }
      ],
      "desc": "Remove transaction from the app. Unlike signatures which will remove all previous signatures when a new one is added, you must clear all previous transactions if you want to reuse the same app",
      "returns": {
        "type": "void",
        "desc": ""
      }
    },
    {
      "name": "arc55_setSignatures",
      "args": [
        {
          "name": "costs",
          "type": "pay",
          "desc": ""
        },
        {
          "name": "transactionGroup",
          "type": "uint64",
          "desc": "Transaction Group nonce"
        },
        {
          "name": "signatures",
          "type": "byte[][]",
          "desc": "Array of signatures"
        }
      ],
      "desc": "Set signatures for a particular transaction group. Signatures must be included as an array of byte-arrays",
      "returns": {
        "type": "void",
        "desc": ""
      }
    },
    {
      "name": "arc55_clearSignatures",
      "args": [
        {
          "name": "transactionGroup",
          "type": "uint64",
          "desc": ""
        },
        {
          "name": "address",
          "type": "address",
          "desc": "Address whose signatures to clear"
        }
      ],
      "desc": "Clear signatures for an address. Be aware this only removes it from the current state of the ledger, and indexers will still know and could use your signature",
      "returns": {
        "type": "void",
        "desc": ""
      }
    }
  ]
}
```

Each deployment is administered by one member of the multisig group, who is responsible for setting up the multisignature metadata using the `arc55_setup(uint8,address[])void` method. After successful deployment and configuration, the application ID **SHOULD** be distributed among the involved parties as a one-time off-chain exchange.

// TODO: Detail New Transaction Group - Extra thought: Should the app refund any unused Algo balance during this call also?

// TODO: How adding/removing transactions work

// TODO: How setting/clearing signatures work
Once a transaction receives enough signatures to meet the threshold and falls within the valid rounds, anyone **MAY** construct the multisignature transaction, including all the signatures, and submit it to the network. Subsequently, participants can clear the signatures from their local state, and the administrator can remove or replace the transactions.

// TODO: Detail cleanup
When an on-chain multisig application is no longer needed, the administrator may destroy the application, reclaiming any Algo funds used for storing the transactions in boxes. Destroying the application does not render the multisignature account inaccessible, as a new deployment with the same multisignature metadata can be configured and used.

Below is a typical expected lifecycle:

 * Admin deploys an ARC55 compliant smart contract.
 * Admin performs setup: Setting threshold to 2, and including 2 accounts.
 * Anyone can now generate a new transaction group.
 * Anyone can add a new transaction to sign to the transaction group, providing the MBR.
 * Account 1 provides their signatures to the transaction group, providing their MBR.
 * Account 2 provides their signatures to the transaction group, providing their MBR.
 * Anyone can now submit the transaction to the network.
 * Anyone can now clear the signatures of each account, refunding their MBR.
 * Anyone removes the transaction since it's now committed to the network, refunding the MBR to the Msig address.

### Storage

```
   n = Transaction group nonce (uint64)
   i = Transaction index within group (uint8)
addr = signers address (byte[32])
```

| Type   | Key         | Value   | Description                                              |
|--------|-------------|---------|----------------------------------------------------------|
| Global | "Threshold" | uint64  | The multisig threshold                                   |
| Global | uint8       | Account | The sub-account index for the multisig                   |
| Global | Account     | uint64  | The number of times this account appears in the multisig |
| Box    | n+i         | byte[]  | The signature for the nth-indexed transaction            |
| Box    | n+addr      | byte[]  | The transactions available for signing "txn0", "txn1"... |

### Cost

Given that all interactions occur on-chain, there are associated costs, excluding the standard transaction fee. Below is an approximate breakdown of the minimum additional costs going by the current costs. Note that a smart contract implementation **MUST** not hardcode any of these values and instead use the AVM's global values to calculate if payments have been met:

| Action          | Storage Cost (microAlgos) | Breakdown                                        |
|-----------------|--------------------------|---------------------------------------------------|
| Creation        | 250,000+                 | 100,000 + (50,000 * (1 + (2 * NumOfSubAccounts))) |
| OptIn           | 900,000                  | 100,000 + (25,000 + 25,000) * 16                  |
| Add Transaction | 72,100+                  | 2,500 + (400 * (4 + TxnSize)) * NumOfTxns         |

## Rationale
### Limitations and Design Decisions

The current design necessitates that all transactions within the group be exclusively signed by the constituents of the multisig account. If a group transaction requires a separate signature from another account or a logicsig, this design does not support it. An extension to this ARC **SHOULD** be considered to address such scenarios.

This ARC inherently promotes transparency of transactions and signers. If an additional layer of anonymity is required, an extension to this ARC **SHOULD** be proposed, outlining how to store and share encrypted data.

Having individual deployments for different groups rather than a single instance that everyone uses has benefits for third-party infrastructure. Managing a large number of boxes for a single application can be cumbersome. Instead, small groups can create their multisig app by having one member deploy the contract. They can then subscribe to the application ID, simplifying the tracking of multisig applications and transactions for wallets and other infrastructure.

## Reference Implementation

A TEALScript reference implementation is available at <a href="https://github.com/nullun/arc55-msig-app">`github.com/nullun/arc55-msig-app`</a> or an older TEAL implementation at <a href="https://github.com/nullun/MsigShare">`github.com/nullun/MsigShare`</a> with a user interface at <a href="https://github.com/nullun/MsigShareUI">`github.com/nullun/MsigShareUI`</a>. It is encouraged for others to implement this standard in their preferred smart contract language of choice and even extend the capabilities whilst adhering to the provided ABI specification.

## Security Considerations

This ARC's design solely involves storing existing data structures and does not have the capability to create or use multisignature accounts. Therefore, the security implications are minimal. End users are expected to review each transaction before generating a signature for it. If a smart contract implementing this ARC lacks proper security checks, the worst-case scenario would involve incorrect transactions and invalid signatures being stored on-chain, along with the potential loss of the minimum balance requirement from the application account.

## Copyright
Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CCO</a>.
